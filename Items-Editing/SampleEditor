local Wave = {}
-------------------------
-------------------------
-------------------------
function Wave:Get_Source()
   local Item, Take, Source, Source_type
      ------------------------------------------------------------------
      Item = reaper.GetSelectedMediaItem(0, 0)
      if Item   then Take = reaper.GetActiveTake(Item) else  return  false,"No Selected Items!"  end 
      if Take   then Source = reaper.GetMediaItemTake_Source(Take) else  return  false,"Empty item!" end
      if Source then Source_type = reaper.GetMediaSourceType(Source,"") end
      -- Fix in future for section ? --
      --[[if Source_type=="SECTION" then Source_type = reaper.GetMediaSourceParent(Source)
             reaper.MB("Sec,fix in future","Info", 0) return 
          end
          local ret, src_offs, src_len, src_rev = reaper.PCM_Source_GetSectionInfo(Source) -- Source_GetSectionInfo,need in future
        ]] 
      ------------------------------------------------------------------
      if Source_type~="WAVE" then return  false,"Invalide Type - "..Source_type end
      ------------------------------------------------------------------
      -- Read data from wav file ---------------------------------------
      ------------------------------------------------------------------
      local FilePath  = reaper.GetMediaSourceFileName(Source , "") -- Source FilePath
      local file = io.open(FilePath,"rb")  -- open file, rb mode
      if not file then return false,"File not available!"  end -- if not available 
      local Data = file:read("*a")         -- read(all)
      file:close()                         -- close file
      --------------------------------------------------------
      --------------------------------------------------------
      local chunkSize     = string.unpack("<I4", Data:sub(5,8))
      local subchunk1Size = string.unpack("<I4", Data:sub(17,20))
      local audioFormat   = string.unpack("<I2", Data:sub(21,22))
      local nchans        = string.unpack("<I2", Data:sub(23,24))
      local srate         = string.unpack("<I4", Data:sub(25,28))
      local byterate      = string.unpack("<I4", Data:sub(29,32))
      local blockalign    = string.unpack("<I2", Data:sub(33,34))
      local bitspersample = string.unpack("<I2", Data:sub(35,36))
      -- If format not supported -----------------------------
      if not((audioFormat==1 and (bitspersample==16 or bitspersample==24)) or (audioFormat==3 and bitspersample==32)) then 
        return  "Format is not supported - "..audioFormat..", "..bitspersample 
      elseif not(nchans==1 or nchans==2) then  return false,"Multichannels is not supported - "..nchans  
      end
      -------------------------------------------------------- 
      local i,j = Data:find("data")  -- find "data" in file
      local subchunk2Size = string.unpack("<I4", Data:sub(j+1,j+4)) -- Data size(in bytes)
      local Datablock = j+5          -- Its Datablock start - attn 1-based !!!
      --- Check data(info) -----------------------------------
      --[[
      reaper.ShowConsoleMsg("audioFormat = "..audioFormat.."\n"..
                            "nchans = "..nchans.."\n"..
                            "bitspersample = "..bitspersample.."\n"..
                            "srate = "..srate.."\n"..
                            "blockalign = "..blockalign.."\n"..
                            "bitspersample = "..bitspersample.."\n"..
                            "Data size(in bytes) = "..subchunk2Size.."\n"..
                            "Datablock start(1-based) = "..Datablock.."\n")
        ]] 
      ------------------------------------------------------------------
      -- Define selection range ----------------------------------------
      ------------------------------------------------------------------
      local Item_start, Item_len, Item_end, sel_start, sel_end
      Item_start = reaper.GetMediaItemInfo_Value(Item,'D_POSITION')
      Item_len   = reaper.GetMediaItemInfo_Value(Item,'D_LENGTH')
      Item_end   = Item_start + Item_len
      sel_start, sel_end = reaper.GetSet_LoopTimeRange(false,false,0,0,false) -- sel start, end
      ------------------------------------------------------------------
      -- Range to item time(and correction to item start-end) ----------
      local sel_start_in_item, sel_end_in_item
      sel_start_in_item = math.max(sel_start - Item_start, 0)      -- sel start in item(time), 0 if < item start
      sel_end_in_item   = math.min(sel_end - Item_start, Item_len) -- sel end in item(time), Item_len if > item end
      if sel_start_in_item>=Item_len or sel_end_in_item<=0 then return false,"Selection out of item"  end
      if sel_end_in_item - sel_start_in_item > 0.1 then sel_end_in_item = sel_start_in_item + 0.1 end -- Limit Selection !
      ------------------------------------------------------------------
      -- Sel Range to item samples(and round inward sel) ---------------
      ------------------------------------------------------------------
      local Proj_srate = srate -- fix it, it must be real Proj_srate for correct support resampled items!!! 
      local sel_start_in_smpls, sel_end_in_smpls, sel_range_in_smpls
      sel_start_in_smpls = math.ceil(sel_start_in_item*Proj_srate)+1 --  in item smpls,attn 1-based !!!
      sel_end_in_smpls   = math.floor(sel_end_in_item*Proj_srate)+1  --  in item smpls,attn 1-based !!!
      sel_range_in_smpls = sel_end_in_smpls - sel_start_in_smpls
      if sel_range_in_smpls<1 then return false,"Sel < 1 smpls"  end
      ----------------------------------------------------------------------
      -- Simple scheme   ||1 -- |D1 (processed part) -- |D2 -- ||   --------
      ----------------------------------------------------------------------
      local  D1, D2, D3
      D1 = Datablock +  (sel_start_in_smpls-1) * blockalign -- Start_Byte
      D2 = D1 +  sel_range_in_smpls * blockalign 
      -------------------------------------------------------
      local Data1,SMPLS,Data2, buf 
      Data1 = Data:sub(1,  D1 - 1) -- ||1 -- |
      SMPLS = Data:sub(D1, D2 - 1) -- |D1 (processed part) -- |
      Data2 = Data:sub(D2)         -- |D2 -- ||
      ---------------------------------------------------------------------
      -- Get samples ------------------------------------------------------
      ---------------------------------------------------------------------
      local buf={};
      local b=1
      -- 16 pcm --
      if bitspersample==16 then
          for i=1,sel_range_in_smpls*nchans do
              buf[i] = string.unpack("<i2", SMPLS:sub(b,b+1)) / 32768
              b=b+2 
          end
      end
      -- 24 pcm --
      if bitspersample==24 then
          for i=1,sel_range_in_smpls*nchans do
              buf[i] = string.unpack("<i3", SMPLS:sub(b,b+2)) / 8388608
              b=b+3 
          end
      end
      -- 32 fp --
      if bitspersample==32 then
          for i=1,sel_range_in_smpls*nchans do
              buf[i] = string.unpack("<f", SMPLS:sub(b,b+3))
              b=b+4 
          end
      end
    ---------------------------------------------------------------------
    ---------------------------------------------------------------------
    self.Item  = Item
    self.Take  = Take
    self.FilePath  = FilePath
    self.nchans    = nchans
    self.srate     = srate
    self.sel_range_in_smpls = sel_range_in_smpls
    self.bitspersample = bitspersample 
    self.Data1 = Data1
    self.Data2 = Data2
    self.buf   = buf
  return true    
end

--------------------------------------------------------------------------------
--   Draw   --------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Mono --
function Wave:Draw_Samples()
    local rds = 3
    local Sx = (gfx.w-10)/self.sel_range_in_smpls
    local Sy = (gfx.h-10)/2
    local Yax = gfx.h/2
    gfx.set(0.7,0.7,0.6)
    gfx.line(0,Yax,gfx.w,Yax,true) 
     -- Draw Samples --
     gfx.set(0.7,0.5,0.6)
     local x,y,x2,y2
     for i=1, #self.buf,1 do
         x = i*Sx;
         -- Get mouse --
         if gfx.mouse_cap&1==1 and math.abs(gfx.mouse_x - x)<= math.max(Sx/2,5) then 
            self.buf[i] = (Yax- gfx.mouse_y)/Sy 
         end 
           -- Draw Point------------
           y = Yax - self.buf[i]*Sy 
           if self.sel_range_in_smpls<256 then gfx.circle(x,y,rds,true,true) end
           -- Draw Line ------------
           if i<#self.buf then
            x2, y2 = (i+1)*Sx , Yax - self.buf[i+1]*Sy  
            gfx.line(x,y,x2,y2,true)
           end
     end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Stereo --
function Wave:Draw_Samples_Stereo()
    local rds = 3
    local Sx = (gfx.w-10)/self.sel_range_in_smpls /2
    local Sy = (gfx.h-10)/2 /2
    local Yax  = (gfx.h/2)
    local Yax1 = (gfx.h/4)
    local Yax2 = (gfx.h/4)*3
    ------------------------
    gfx.set(0.3,0.7,0.6,0.5)
    gfx.line(0,Yax,gfx.w,Yax,true)
    gfx.set(0.7,0.7,0.6,0.5)
    gfx.line(0,Yax1,gfx.w,Yax1,true)
    gfx.line(0,Yax2,gfx.w,Yax2,true) 
     ------------------------------
     -- Draw Samples 1 --
     ------------------------------
     gfx.set(0.7,0.5,0.6,1)
     local x,y,x2,y2
     for i=1, #self.buf,2 do
          x = i*Sx;
          -- Get mouse 1 --------------------------------------
          if gfx.mouse_cap&1==1 and mouse_oy<=Yax and math.abs(gfx.mouse_x - x)<= math.max(Sx,5) and 
             gfx.mouse_y<=Yax and gfx.mouse_y>=0  then 
             self.buf[i] = (Yax1- gfx.mouse_y)/Sy 
          end 
            -- Draw Point------------
            y = Yax1 - self.buf[i]*Sy 
            if self.sel_range_in_smpls <256 then gfx.circle(x,y,rds,true,true) end
            -- Draw Line ------------
            if i<#self.buf-1 then
             x2, y2 = (i+2)*Sx , Yax1 - self.buf[i+2]*Sy  
             gfx.line(x,y,x2,y2,true)
            end
     end
     ------------------------------
     -- Draw Samples 2 --
     ------------------------------
     gfx.set(0.5,0.7,0.6,1)
     for i=2, #self.buf,2 do
          x = (i-1)*Sx;
          -- Get mouse 2 ---------------------------------------
          if gfx.mouse_cap&1==1 and mouse_oy>=Yax and math.abs(gfx.mouse_x - x)<= math.max(Sx,5) and 
             gfx.mouse_y>=Yax and gfx.mouse_y<=gfx.h  then 
             self.buf[i] = (Yax2- gfx.mouse_y)/Sy 
          end 
            -- Draw Point------------
            y = Yax2 - self.buf[i]*Sy 
            if self.sel_range_in_smpls <256 then gfx.circle(x,y,rds,true,true) end
            -- Draw Line ------------
            if i<#self.buf-1 then
               x2, y2 = (i+2-1)*Sx , Yax2 - self.buf[i+2]*Sy  
               gfx.line(x,y,x2,y2,true)
            end  
     end
end

----------------------------------------------------------------------------------
--- Rewrite_Wave_File ------------------------------------------------------------
----------------------------------------------------------------------------------
function Wave:Rewrite_File()
    ------------------------------------------------
    --- Open File ----------------------------------
    ------------------------------------------------
    if self.buf and self.FilePath then reaper.Main_OnCommand(40440, 0) -- offline(40100-may be all?)
       file = io.open(self.FilePath,"wb")                         -- file in "wb"
       if not file then reaper.Main_OnCommand(40439, 0)
          return reaper.MB("File Not aviable for write!", "Info", 0)
       end
    end
    ------------------------------------------------
    --- Buffer_to_chars ----------------------------
    ------------------------------------------------
    -- for 16 bit norm to int ----------------------
     function norm_to_int16(inp)
      local out
          if inp<0 then 
               if inp<=-1 then out = -32768 
               else out = math.modf((inp * 32768)-0.5)
               end
            elseif inp>=(32766.5/32768.0) then out = 32767 
            else out = math.modf((inp * 32768)+ 0.5)
          end
       return out
     end
     -- for 24 bit norm to int ---------------------
      function norm_to_int24(inp)
       local out
           if inp<0 then 
                if inp<=-1 then out = -8388608 
                else out = math.modf((inp * 8388608)-0.5)
                end
             elseif inp>=(8388606.5/8388608) then out = 8388607 
             else out = math.modf((inp * 8388608)+ 0.5)
           end
        return out
      end
    
    ------------------------------------------------
    ------------------------------------------------  
    local Data_buf = {} 
        -- 16 pcm -----------------
      if self.bitspersample == 16 then
        for i=1, #self.buf do
            local inp = self.buf[i]
            local out = norm_to_int16(inp)
            -----------
            Data_buf[i] = string.pack("<i2", out) --little-endian
        end
      end
        -- 24 pcm -----------------
     if self.bitspersample == 24 then
        for i=1, #self.buf do
            local inp = self.buf[i]
            local out = norm_to_int24(inp)
            -----------
            Data_buf[i] = string.pack("<i3", out) --little-endian 
        end
     end 
        -- 32 fp ------------------
     if self.bitspersample == 32 then 
        for i=1, #self.buf do
            Data_buf[i] = string.pack("<f", self.buf[i]) --little-endian
        end  
     end
    
    ------------------------------------------------
    -- Write --------------------------------------- 
    ------------------------------------------------  
    Data = table.concat(Data_buf) -- Concat(Its wave Data!!!)  
    ------------------------
    -- Write Head,Data -----
    ------------------------
    file:write(self.Data1,Data,self.Data2)
    file:close()
    ------------------------
    ------------------------
    reaper.Main_OnCommand(40439, 0) -- online(40101-may be all?)
    reaper.Main_OnCommand(40441, 0) -- rebuild peaks 
    reaper.UpdateItemInProject(reaper.GetSelectedMediaItem(0, 0))
    reaper.UpdateArrange()
end

--------------------------------------------------------------------------------
--   Proj_Change   -------------------------------------------------------------
--------------------------------------------------------------------------------
function Proj_Change()
    local cur_cnt = reaper.GetProjectStateChangeCount(0)
    if not Proj_Change_cnt or cur_cnt ~= Proj_Change_cnt then
       Proj_Change_cnt = cur_cnt
       return true  
    end
end
--------------------------------------------------------------------------------
--   INIT   --------------------------------------------------------------------
--------------------------------------------------------------------------------
function Init()
    -- Some gfx Wnd Default Values ---------------
    local R,G,B = 20,20,20              -- 0...255 format
    local Wnd_bgd = R + G*256 + B*65536 -- red+green*256+blue*65536  
    local Wnd_Title = "TEST"
    local Wnd_Dock,Wnd_X,Wnd_Y = 0,100,320 
    Wnd_W,Wnd_H = 1044,490 -- global values(used for define zoom level)
    -- Init window ------
    gfx.clear = Wnd_bgd         
    gfx.init( Wnd_Title, Wnd_W,Wnd_H, Wnd_Dock, Wnd_X,Wnd_Y )
    -- Init mouse last --
    last_mouse_cap = 0
    last_x, last_y = 0, 0
    mouse_ox, mouse_oy = -1, -1
end
----------------------------------------
--   Mainloop   ------------------------
----------------------------------------
function mainloop()
    -- zoom level -- 
    Z_w, Z_h = gfx.w/Wnd_W, gfx.h/Wnd_H
    if Z_w<0.6 then Z_w = 0.6 elseif Z_w>2 then Z_w = 2 end 
    if Z_h<0.6 then Z_h = 0.6 elseif Z_h>2 then Z_h = 2 end 
    -- mouse and modkeys --
    if gfx.mouse_cap&1==1   and last_mouse_cap&1==0  or   --L mouse
       gfx.mouse_cap&2==2   and last_mouse_cap&2==0  or   --R mouse
       gfx.mouse_cap&64==64 and last_mouse_cap&64==0 then --M mouse
       mouse_ox, mouse_oy = gfx.mouse_x, gfx.mouse_y 
    end
    Ctrl  = gfx.mouse_cap&4==4   -- Ctrl  state
    Shift = gfx.mouse_cap&8==8   -- Shift state
    Alt   = gfx.mouse_cap&16==16 -- Shift state
    -------------------------
    if Proj_Change() then W,msg = Wave:Get_Source() end
    -------------------------
    -- DRAW,MAIN functions --
    -------------------------
     if W==true then  
       if Wave.nchans==1 then Wave:Draw_Samples() 
         else Wave:Draw_Samples_Stereo()
       end
       else gfx.setfont(1,"Ariael", 25); gfx.set(0.7,0.7,0.7); gfx.x=20; gfx.y=20; gfx.drawstr(msg)
     end
     ----
     if gfx.mouse_cap&1==0 and last_mouse_cap&1==1 then 
        Wave:Rewrite_File() 
     end
    -------------------------
    -------------------------
    last_mouse_cap = gfx.mouse_cap
    last_x, last_y = gfx.mouse_x, gfx.mouse_y
    char = gfx.getchar() 
    if char==32 then reaper.Main_OnCommand(40044, 0) end --play
    if char~=-1 then reaper.defer(mainloop) end          --defer       
    -----------  
    gfx.update()
    -----------
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--reaper.ClearConsole()
Init()
mainloop()

----------------------
----------------------
Wave:Get_Source()
