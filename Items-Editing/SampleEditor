local Wave = {}
-------------------------
-------------------------
-------------------------
function Wave:Get_Source()
   local Item, Take, Source, Source_type
      ------------------------------------------------------------------
      Item = reaper.GetSelectedMediaItem(0, 0)
      if Item   then Take = reaper.GetActiveTake(Item) else  return  false,"No Selected Items!"  end 
      if Take   then Source = reaper.GetMediaItemTake_Source(Take) else  return  false,"Empty item!" end
      if Source then Source_type = reaper.GetMediaSourceType(Source,"") end
      -- Fix in future for section ? --
      --[[if Source_type=="SECTION" then Source_type = reaper.GetMediaSourceParent(Source)
             reaper.MB("Sec,fix in future","Info", 0) return 
          end
          local ret, src_offs, src_len, src_rev = reaper.PCM_Source_GetSectionInfo(Source) -- Source_GetSectionInfo,need in future
        ]] 
      ------------------------------------------------------------------
      if Source_type~="WAVE" then return  false,"Invalide Type - "..Source_type end
      ------------------------------------------------------------------
      -- Read data from wav file ---------------------------------------
      ------------------------------------------------------------------
      local FilePath  = reaper.GetMediaSourceFileName(Source , "") -- Source FilePath
      local file = io.open(FilePath,"rb")  -- open file, rb mode
      if not file then return false,"File not available!"  end -- if not available 
      local Data = file:read("*a")         -- read(all)
      file:close()                         -- close file
      --------------------------------------------------------
      --------------------------------------------------------
      local chunkSize     = string.unpack("<I4", Data:sub(5,8))
      local subchunk1Size = string.unpack("<I4", Data:sub(17,20))
      local audioFormat   = string.unpack("<I2", Data:sub(21,22))
      local nchans        = string.unpack("<I2", Data:sub(23,24))
      local srate         = string.unpack("<I4", Data:sub(25,28))
      local byterate      = string.unpack("<I4", Data:sub(29,32))
      local blockalign    = string.unpack("<I2", Data:sub(33,34))
      local bitspersample = string.unpack("<I2", Data:sub(35,36))
      -- If format not supported -----------------------------
      if not((audioFormat==1 and (bitspersample==16 or bitspersample==24)) or (audioFormat==3 and bitspersample==32)) then 
        return  "Format is not supported - "..audioFormat..", "..bitspersample 
      --elseif not(nchans==1 or nchans==2) then  return false,"Multichannels is not supported - "..nchans  
      end
      -------------------------------------------------------- 
      local i,j = Data:find("data")  -- find "data" in file
      local subchunk2Size = string.unpack("<I4", Data:sub(j+1,j+4)) -- Data size(in bytes)
      local Datablock = j+5          -- Its Datablock start - attn 1-based !!!
      --- Check data(info) -----------------------------------
      --[[
      reaper.ShowConsoleMsg("audioFormat = "..audioFormat.."\n"..
                            "nchans = "..nchans.."\n"..
                            "bitspersample = "..bitspersample.."\n"..
                            "srate = "..srate.."\n"..
                            "blockalign = "..blockalign.."\n"..
                            "bitspersample = "..bitspersample.."\n"..
                            "Data size(in bytes) = "..subchunk2Size.."\n"..
                            "Datablock start(1-based) = "..Datablock.."\n")
        ]] 
      ------------------------------------------------------------------
      -- Define selection range ----------------------------------------
      ------------------------------------------------------------------
      local Item_start, Item_len, Item_end, sel_start, sel_end
      Item_start = reaper.GetMediaItemInfo_Value(Item,'D_POSITION')
      Item_len   = reaper.GetMediaItemInfo_Value(Item,'D_LENGTH')
      Item_end   = Item_start + Item_len
      sel_start, sel_end = reaper.GetSet_LoopTimeRange(false,false,0,0,false) -- sel start, end
      ------------------------------------------------------------------
      -- Range to item time(and correction to item start-end) ----------
      local sel_start_in_item, sel_end_in_item
      sel_start_in_item = math.max(sel_start - Item_start, 0)      -- sel start in item(time), 0 if < item start
      sel_end_in_item   = math.min(sel_end - Item_start, Item_len) -- sel end in item(time), Item_len if > item end
      if sel_start_in_item>=Item_len or sel_end_in_item<=0 then return false,"Selection out of item or no exist" end
      if sel_end_in_item - sel_start_in_item > 0.1 then sel_end_in_item = sel_start_in_item + 0.1 end -- Limit Selection !
      ------------------------------------------------------------------
      -- Sel Range to item samples(and round inward sel) ---------------
      ------------------------------------------------------------------
      local Proj_srate = srate -- fix it, it must be real Proj_srate for correct support resampled items!!! 
      local sel_start_in_smpls, sel_end_in_smpls, sel_range_in_smpls
      sel_start_in_smpls = math.ceil(sel_start_in_item*Proj_srate)+1 --  in item smpls,attn 1-based !!!
      sel_end_in_smpls   = math.floor(sel_end_in_item*Proj_srate)+1  --  in item smpls,attn 1-based !!!
      sel_range_in_smpls = sel_end_in_smpls - sel_start_in_smpls +1
      if sel_range_in_smpls<2 then return false,"Sel < 2 smpls"  end
      ----------------------------------------------------------------------
      -- Simple scheme   ||1 -- |D1 (processed part) -- |D2 -- ||   --------
      ----------------------------------------------------------------------
      local  D1, D2, D3
      D1 = Datablock +  (sel_start_in_smpls-1) * blockalign -- Start_Byte
      D2 = D1 +  sel_range_in_smpls * blockalign 
      -------------------------------------------------------
      local Data1,SMPLS,Data2 
      Data1 = Data:sub(1,  D1 - 1) -- ||1 -- |
      SMPLS = Data:sub(D1, D2 - 1) -- |D1 (processed part) -- |
      Data2 = Data:sub(D2)         -- |D2 -- ||
      -----------------------------------------------------------------------------------
      -- Get samples --------------------------------------------------------------------
      -----------------------------------------------------------------------------------
      local buf={}   -- Its sample buffer!
      local Pfmt,Bps -- Pack format, BYTES per sample ------
        if bitspersample==16 then Pfmt = "<i2"; Bps = 2 end
        if bitspersample==24 then Pfmt = "<i3"; Bps = 3 end
        if bitspersample==32 then Pfmt = "<f" ; Bps = 4 end
      ------------------------------------------------------
      -- Unpuck values -------------------------------------
      ------------------------------------------------------
      local b=1
      for i=1, sel_range_in_smpls*nchans do
          buf[i] = string.unpack(Pfmt, SMPLS:sub(b, b+Bps-1) ) -- val to buffer 
          b = b+Bps 
      end
    ---------------------------------------------------------------------
    -- Define self values  ----------------------------------------------
    ---------------------------------------------------------------------
    self.Item  = Item
    self.Take  = Take
    self.FilePath  = FilePath
    self.nchans    = nchans
    self.srate     = srate
    self.sel_range_in_smpls = sel_range_in_smpls
    self.bitspersample = bitspersample 
    self.Data1 = Data1
    self.Data2 = Data2
    self.buf   = buf
    self.Pfmt  = Pfmt
    self.Bps   = Bps
  return true    
end

--------------------------------------------------------------------------------
--   Draw   --------------------------------------------------------------------
--------------------------------------------------------------------------------
function Wave:Draw_Samples(chan, Wx,Wy,Ww,Wh, r,g,b,a)
    local Ay = Wy + Wh/2 -- axis y-coord 
    local Srds = 3       -- sample "point" radius
    -------------------
    local Sx,Sy,Srng -- Sx,Sy = x,y smpl scales in gfx, Srng = smpl Value range
      if self.bitspersample==32 then Srng = 1 else Srng = 2^(self.bitspersample-1) end
      Sx = (Ww/(self.sel_range_in_smpls-1)) /self.nchans
      Sy = (Wh/2) /Srng  
    -- Draw axis -------
    gfx.set(0.7,0.7,0.6,0.7)
    gfx.line(Wx, Ay, Wx+Ww, Ay, true) 
     ------------------------------------------
     -- Draw Samples(and get mouse) -----------
     ------------------------------------------
     gfx.set(r,g,b,a)
     local x,y,x2,y2
     for i=chan, #self.buf, self.nchans do
         x = Wx + (i-chan)*Sx -- sample x-position 
         --------------------------------------
         -- Get mouse -------------------------
         if gfx.mouse_cap&1==1 and math.abs(gfx.mouse_x - x)<= math.max(Sx*self.nchans/2, 5) and 
            mouse_oy>=Wy and mouse_oy<=Wy+Wh  then local smpl = (Ay - gfx.mouse_y)/Sy
              -- valid value --
              if self.bitspersample==16 or self.bitspersample==24 then smpl = math.floor(smpl + 0.5)
                  if smpl>Srng-1 then smpl = Srng-1 elseif smpl< -Srng then smpl = -Srng end -- valid 16,24 smpl range
              elseif self.bitspersample==32 then
                  if smpl>1      then smpl = 1      elseif smpl< -1    then smpl = -1    end -- valid 32 smpl range
              end
            self.buf[i] = smpl -- to buffer
         end 
           ------------------------------------
           -- Draw sample Point ---------------
           y = Ay - self.buf[i]*Sy 
           if self.sel_range_in_smpls<256 then gfx.circle(x,y,Srds,true,true) end
           ------------------------------------
           -- Draw line current-next sample ---
           if i < #self.buf-self.nchans+chan then
              x2, y2 = Wx + Wx + (i-chan+self.nchans)*Sx, Ay - self.buf[i+self.nchans]*Sy  
              gfx.line(x,y,x2,y2,true)
           end
     end
end

----------------------------------------------------------------------------------
--- Rewrite_Wave_File ------------------------------------------------------------
----------------------------------------------------------------------------------
function Wave:Rewrite_File()
    ------------------------------------------------
    --- Open File ----------------------------------
    ------------------------------------------------
    if self.buf and self.FilePath then reaper.Main_OnCommand(40440, 0) -- offline(40100-may be all?)
       file = io.open(self.FilePath,"wb")                         -- file in "wb"
       if not file then reaper.Main_OnCommand(40439, 0)
          return reaper.MB("File Not aviable for write!", "Info", 0)
       end
    end
    ------------------------------------------------
    --- Buffer_to_chars ----------------------------
    ------------------------------------------------ 
    local Data_buf = {} 
    -- Puck values  -----
    for i=1, #self.buf do
        Data_buf[i] = string.pack(self.Pfmt, self.buf[i]) --little-endian
    end    
    ------------------------------------------------
    -- Write --------------------------------------- 
    ------------------------------------------------  
    local Data = table.concat(Data_buf) -- Concat(Its wave Data!!!)  
    ------------------------
    -- Write Head,Data -----
    ------------------------
    file:write(self.Data1,Data,self.Data2)
    file:close()
    ------------------------
    ------------------------
    reaper.Main_OnCommand(40439, 0) -- online(40101-may be all?)
    reaper.Main_OnCommand(40441, 0) -- rebuild peaks 
    reaper.UpdateItemInProject(reaper.GetSelectedMediaItem(0, 0))
    reaper.UpdateArrange()
end

--------------------------------------------------------------------------------
--   Proj_Change   -------------------------------------------------------------
--------------------------------------------------------------------------------
function Proj_Change()
    local cur_cnt = reaper.GetProjectStateChangeCount(0)
    if not Proj_Change_cnt or cur_cnt ~= Proj_Change_cnt then
       Proj_Change_cnt = cur_cnt
       return true  
    end
end
--------------------------------------------------------------------------------
--   INIT   --------------------------------------------------------------------
--------------------------------------------------------------------------------
function Init()
    -- Some gfx Wnd Default Values ---------------
    local R,G,B = 20,20,20              -- 0...255 format
    local Wnd_bgd = R + G*256 + B*65536 -- red+green*256+blue*65536  
    local Wnd_Title = "Sample Editor b1"
    local Wnd_Dock,Wnd_X,Wnd_Y = 0,100,320 
    Wnd_W,Wnd_H = 1044,490 -- global values(used for define zoom level)
    -- Init window ------
    gfx.clear = Wnd_bgd         
    gfx.init( Wnd_Title, Wnd_W,Wnd_H, Wnd_Dock, Wnd_X,Wnd_Y )
    -- Init mouse last --
    last_mouse_cap = 0
    last_x, last_y = 0, 0
    mouse_ox, mouse_oy = -1, -1
end
----------------------------------------
--   Mainloop   ------------------------
----------------------------------------
function mainloop()
    -- zoom level -- 
    Z_w, Z_h = gfx.w/Wnd_W, gfx.h/Wnd_H
    if Z_w<0.6 then Z_w = 0.6 elseif Z_w>2 then Z_w = 2 end 
    if Z_h<0.6 then Z_h = 0.6 elseif Z_h>2 then Z_h = 2 end 
    -- mouse and modkeys --
    if gfx.mouse_cap&1==1   and last_mouse_cap&1==0  or   --L mouse
       gfx.mouse_cap&2==2   and last_mouse_cap&2==0  or   --R mouse
       gfx.mouse_cap&64==64 and last_mouse_cap&64==0 then --M mouse
       mouse_ox, mouse_oy = gfx.mouse_x, gfx.mouse_y 
    end
    Ctrl  = gfx.mouse_cap&4==4   -- Ctrl  state
    Shift = gfx.mouse_cap&8==8   -- Shift state
    Alt   = gfx.mouse_cap&16==16 -- Shift state
    -------------------------
    if Proj_Change() then W,msg = Wave:Get_Source() end
    -------------------------
    -- DRAW,MAIN functions --
    -------------------------
    if W==true then
       local Wh = gfx.h/Wave.nchans
       local r,g,b,a = 0.7,0.5,0.6,1
       for chan=1, Wave.nchans do
           gfx.set(0.4,0.7,0.3,0.7)
           gfx.line(0,Wh*chan, gfx.w, Wh*chan, true)
           Wave:Draw_Samples(chan, 0,  Wh*(chan-1),  gfx.w, Wh, r,g,b,a) -- chan, Wx,Wy,Ww,Wh 
           r,g = g,r -- reverse r,g  
       end
    else gfx.setfont(1,"Arial", 25); gfx.set(0.7,0.7,0.7); gfx.x=20; gfx.y=20; gfx.drawstr(msg)
    end
     ----
     if gfx.mouse_cap&1==0 and last_mouse_cap&1==1 then 
        Wave:Rewrite_File() 
     end
    -------------------------
    -------------------------
    last_mouse_cap = gfx.mouse_cap
    last_x, last_y = gfx.mouse_x, gfx.mouse_y
    char = gfx.getchar() 
    if char==32 then reaper.Main_OnCommand(40044, 0) end --play
    if char~=-1 then reaper.defer(mainloop) end          --defer       
    -----------  
    gfx.update()
    -----------
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--reaper.ClearConsole()
Init()
mainloop()
